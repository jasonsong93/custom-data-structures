ChatGPT generated these

| Method                 | Pros                                                                         | Cons                                                                                                                                                 | Best Use Case / Notes                                                |
| ---------------------- | ---------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------- |
| **Separate Chaining**  | - Simple to implement<br>- Handles high load factors well<br>- Easy deletion | - Extra memory for pointers/lists<br>- Poor cache locality due to pointer chasing<br>- Performance degrades if chains get long                       | General-purpose hash tables, when memory overhead is acceptable      |
| **Linear Probing**     | - Simple and cache friendly<br>- No extra pointers needed                    | - Primary clustering slows down lookup/inserts<br>- Performance degrades quickly beyond \~70% load<br>- Deletion needs tombstones (extra complexity) | Memory-constrained environments with low to moderate load factor     |
| **Quadratic Probing**  | - Reduces primary clustering compared to linear probing<br>- Cache friendly  | - Secondary clustering still possible<br>- Needs careful table size and probing parameters<br>- More complex than linear probing                     | Situations needing better clustering control without extra memory    |
| **Double Hashing**     | - Minimizes clustering more effectively<br>- Better distribution             | - Requires two good hash functions<br>- More computational overhead                                                                                  | Performance-critical hash tables where clustering must be minimized  |
| **Robin Hood Hashing** | - More even probe sequence lengths<br>- Better worst-case lookup times       | - More complex insert logic<br>- Slightly more overhead managing probe distances                                                                     | Systems where predictable lookup time is important                   |
| **Cuckoo Hashing**     | - Constant worst-case lookup time<br>- Simple lookups                        | - Insertion can be expensive (kick-outs)<br>- Possible infinite loops requiring rehash<br>- More complex to implement                                | High-performance systems where lookups are frequent and must be fast |
| **Perfect Hashing**    | - Zero collisions (constant lookup time)<br>- Optimal for static sets        | - Only works on fixed key sets<br>- Expensive to build perfect hash functions                                                                        | Static key sets, like keyword tables or compilers                    |
